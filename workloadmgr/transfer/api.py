# Copyright (C) 2013 Hewlett-Packard Development Company, L.P.
# All Rights Reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

"""
Handles all requests relating to transferring ownership of workloads.
"""


import datetime
import hashlib
import hmac
import json
import os
import uuid

from oslo_config import cfg
from oslo_log import log as logging
from oslo_utils import excutils

from workloadmgr.db import base
from workloadmgr import exception
from workloadmgr.common.i18n import _, _LE, _LI, _LW
from workloadmgr.workloads import api as workload_api
from workloadmgr.vault import vault
from workloadmgr import auditlog


workload_transfer_opts = [
    cfg.IntOpt('workload_transfer_salt_length', default=8,
               help='The number of characters in the salt.'),
    cfg.IntOpt('workload_transfer_key_length', default=16,
               help='The number of characters in the '
               'autogenerated auth key.'), ]

CONF = cfg.CONF
CONF.register_opts(workload_transfer_opts)

LOG = logging.getLogger(__name__)
AUDITLOG = auditlog.getAuditLogger()


class API(base.Base):
    """API for interacting workload transfers."""

    def __init__(self, db_driver=None):
        self.workload_api = workload_api.API()
        super(API, self).__init__(db_driver)


    def _update_workload_ownership_on_media(context, workload_id):
        pass

    def get(self, context, transfer_id):
        try:
            transfer_rec = [trans_rec for trans_rec in self.get_all(context) 
                            if trans_rec['id'] == transfer_id]
            return transfer_rec[0]
        except:
            raise exception.TransferNotFound(transfer_id=transfer_id)

    def delete(self, context, transfer_id):
        """Make the RPC call to delete a workload transfer."""
        workload_api.check_policy(context, 'delete_transfer')
        transfer_rec = self.get(context, transfer_id)

        AUDITLOG.log(context, 'Transfer \'' + transfer_id + '\' Delete  Requested')
        workload_ref = self.db.workload_get(context, transfer_rec['workload_id'])
        if workload_ref['status'] != 'awaiting-transfer':
            LOG.error(_LE("Workload in unexpected state"))

        self.db.workload_update(context, workload_ref.id,
                                {'status': 'available'})
        vault.transfers_delete(context, transfer_rec)
        self.workload_api.workload_resume(context, workload_ref.id)

    def get_all(self, context, filters=None):
        filters = filters or {}
        workload_api.check_policy(context, 'get_all_transfers')
        all_transfers = vault.get_all_workload_transfers()
        transfers = []
        for transfer_file in all_transfers:
            tran = json.loads(vault.get_object(transfer_file))
       
            if context.is_admin and 'all_tenants' in filters:
                transfers.append(tran)
            elif context.project_id == tran['project_id']:
                transfers.append(tran)

        return transfers

    def _get_random_string(self, length):
        """Get a random hex string of the specified length."""
        rndstr = ""

        # Note that the string returned by this function must contain only
        # characters that the recipient can enter on their keyboard. The
        # function ssh224().hexdigit() achieves this by generating a hash
        # which will only contain hexidecimal digits.
        while len(rndstr) < length:
            rndstr += hashlib.sha224(os.urandom(255)).hexdigest()

        return rndstr[0:length]

    def _get_crypt_hash(self, salt, auth_key):
        """Generate a random hash based on the salt and the auth key."""
        return hmac.new(str(salt),
                        str(auth_key),
                        hashlib.sha1).hexdigest()

    def create(self, context, workload_id, display_name):
        """Creates an entry in the transfers table."""
        workload_api.check_policy(context, 'create_transfer')
        LOG.info(_LI("Generating transfer record for workload %s"), workload_id)
        workload_ref = self.db.workload_get(context, workload_id)

        AUDITLOG.log(context, 'Transfer for workload \'' + workload_id + '\' Create  Requested')
        if context.project_id != workload_ref.project_id:
            raise exception.InvalidWorkload(reason=_("status must be available"))

        if workload_ref['status'] != "available":
            raise exception.InvalidState(reason=_("Workload is not in 'available' state"))

        # The salt is just a short random string.
        salt = self._get_random_string(CONF.workload_transfer_salt_length)
        auth_key = self._get_random_string(CONF.workload_transfer_key_length)
        crypt_hash = self._get_crypt_hash(salt, auth_key)

        # TODO: Transfer expiry needs to be implemented.
        transfer_rec = {
                        'id': str(uuid.uuid4()),
                        'workload_id': workload_id,
                        'user_id': context.user_id,
                        'project_id': context.project_id,
                        'display_name': display_name,
                        'salt': salt,
                        'crypt_hash': crypt_hash,
                        'expires_at': None,
                        'created_at': str(datetime.datetime.now()),
                        }

        #
        # 1. Mark workload as transfer-in-progress
        #
        try:
            transfer_rec_path = vault.get_workload_transfers_path(transfer_rec)
            vault.put_object(transfer_rec_path, json.dumps(transfer_rec))
        except Exception:
            LOG.error(_LE("Failed to create transfer record "
                          "for %s"), workload_id)
            raise

        self.db.workload_update(context, workload_id, {'status': 'transfer-in-progress'})
        self.workload_api.workload_pause(context, workload_id)

        return {'id': transfer_rec['id'],
                'workload_id': transfer_rec['workload_id'],
                'display_name': transfer_rec['display_name'],
                'auth_key': auth_key,
                'created_at': transfer_rec['created_at']}

    @workload_api.create_trust
    def accept(self, context, transfer_id, auth_key):
        """Accept a workload that has been offered for transfer."""
        # We must use an elevated context to see the workload that is still
        # owned by the donor.
        workload_api.check_policy(context, 'accept_transfer')
        transfer = self.get(context, transfer_id)

        AUDITLOG.log(context, 'Transfer \'' + transfer_id + '\' Accept  Requested')
        crypt_hash = self._get_crypt_hash(transfer['salt'], auth_key)
        if crypt_hash != transfer['crypt_hash']:
            msg = (_("Attempt to transfer %s with invalid auth key.") %
                   transfer_id)
            LOG.error(msg)
            raise exception.InvalidAuthKey(reason=msg)

        workload_id = transfer['workload_id']
 
        # read the workload manager and snapshots record from the nfs share
        # and change user ids and tenant id
        try:
            workload_ref = self.db.workload_get(context, workload_id)
            raise exception.TransferNotAllowed(workload_id=workload_id)
        except:
            pass

        try:
            # Transfer ownership of the workload now, must use an elevated
            # context.
            vault._update_workload_ownership_on_media(context.elevated(),
                                                      workload_id)

            self.delete(context, transfer_id)

            # import workload now
            workloadAPI.import_workloads(context, [workload_id], False)
            LOG.info(_LI("Workload %s has been transferred."), workload_id)
        except Exception:
            raise

        workload_ref = {'id': 'Dummy'} #self.db.workload_get(context, workload_id)
        return {'id': transfer_id,
                'display_name': transfer['display_name'],
                'workload_id': workload_ref['id']}

    # complete is executed on the cloud that transfer is initiated
    def complete(self, context, transfer_id):
        transfer = self.get(context, transfer_id)

        AUDITLOG.log(context, 'Transfer \'' + transfer_id + '\' Complete  Requested')
        if transfer is None:
            raise exception.TransferNotFound(transfer_id = transfer_id)

    # complete is executed on the cloud that transfer is initiated
    def abort(self, context, transfer_id):
        transfer = self.get(context, transfer_id)

        AUDITLOG.log(context, 'Transfer \'' + transfer_id + '\' Abort  Requested')
        if transfer is None:
            raise exception.TransferNotFound(transfer_id = transfer_id)
